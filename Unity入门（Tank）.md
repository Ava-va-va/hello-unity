- [[#基础操作|基础操作]]
- [[#UI设计|UI设计]]
- [[#一些方法|一些方法]]
- [[#按键检测|按键检测]]
- [[#一些单词|一些单词]]
- [[#父子级|父子级]]
- [[#空对象，预制体|空对象，预制体]]
- [[#GameManager|GameManager]]
- [[#一些其他操作知识|一些其他操作知识]]
- [[#一些其他操作知识#tank 场景环境设置|tank 场景环境设置]]
- [[#一些其他操作知识#tank设置|tank设置]]
- [[#tank设置#设置碰撞器的位置和大小|设置碰撞器的位置和大小]]
- [[#tank设置#设置相机|设置相机]]
- [[#tank设置#轴线相关信息|轴线相关信息]]
- [[#tank设置#声音相关的设置|声音相关的设置]]
- [[#tank设置#尾气设置（粒子特效）|尾气设置（粒子特效）]]
- [[#tank设置#炮弹设置|炮弹设置]]
- [[#tank设置#炮弹发射思路|炮弹发射思路]]
- [[#tank设置#炮弹蓄力时的处理思路|炮弹蓄力时的处理思路]]
- [[#tank设置#画布大小调整|画布大小调整]]
- [[#tank设置#游戏初始化tank生成|游戏初始化tank生成]]
- [[#tank设置#音频混合器|音频混合器]]
- [[#音频混合器#音量压制|音量压制]]
- [[#音频混合器#一些理解|一些理解]]
- [[#tank设置#游戏打包|游戏打包]]
- [[#游戏打包#BuildTargetGroup|BuildTargetGroup]]

###### 基础操作  

1. 游戏设计流程不单一，脚本代码的创建要跟着游戏设计的流程和逻辑走，每个人的逻辑和流程不一定相同
2. 鼠标右键是漫游，也就是视角查看。移动的话按住右键并且wasd即可
3. 漫游的时候q是下e是上
4. ctrl+z是撤销上一步操作。比如点击摄像机的时候，按ctrl+z可以关闭摄像机
5. 通过摄像机展示游戏画面
6. 左边栏  ：手； 移动（W）；  旋转（E）；  缩放（R）  ；矩形工具（T）（通过拉拽的方式缩放）； 变换组件工具（将前面的工具进行了简单的整合）；
7. 给场景中添加  物体  文本  代码  文件  脚本 文件夹 等，都在Assets中完成
8. 局部 中对物体进行操作会改变坐标轴的位置。全局不会
9. 缩放里面的参数是调整物体的大小，单位是米
10. mesh是呈现的一个样子（网格形状）       materials（材质）可以认为是显示的一种颜色或者是一种表现形式，也就是表面应该展现出一种什么样子（换色皮）。
11. Ridgedbody 刚体  ：使_游戏对象_的行为方式受物理控制。刚体可以接受力和扭矩，使对象以逼真的方式移动。任何游戏对象都必须包含受重力影响的刚体，行为方式基于施加的作用力（通过脚本），或通过 NVIDIA PhysX 物理引擎与其他对象交互。
12.  Vector（向量）      将1.5转换成float类型直接写1.5f（系统默认为double，需要写f将其转换）
13. unity中想看到控制台输出必须使用Debug.Log().    这与c#中的控制台应用程序不同。unity中的是第三方的提供的方法，才能与之匹配。
14. 在unity中，start方法相当于变相的main方法
15. 游戏是实时运行的，会向画面（屏幕）中不断的输出画面，所以unity提供了一个方法（Update），来实时的修改画面中的一些数据，或者是其他的行为，比如输出位置，时间之类的。
16. 脚本API里有Unity提供的所有的命名空间，类型，方法等的说明
17. 游戏中的缩放是用向量的形式来表示的（就是向量和常数相乘）
18. 组件对应的是c#的类型
19.  ctrl+z是撤回上一步操作      选中物体按ctrl+d是重新复制物体     ctrl+鼠标左键可以选中多个物体
20. 在游戏中一般使用场景的形式来进行关卡的切换，一个关卡就是一个场景，或者一个场景就是一个关卡。比如进入到教学楼，是要进行游戏的加载。就是从外面的场景进入到另一个场景，教学楼就是一个cube
21. 窗口选项有资源商店和包管理器，在资源商店添加的资源可以在包管理器中找到，在包：我的资产中可以找到，点击下载，下载完成之后导入到项目中
22. fixedupdate  固定更新;   可以固定帧率，物理运动的量放在其中
23. update是与游戏运行时的帧率相关的，不能固定，非物理相关的量放在其中
24. 资源的完整代码可以在添加组件中查找
25. Awake要比Start执行更早，可以在执行Awake的时候就获取基础的组件信息。比如：Rigidbody组件
	1. Awake
26. 将Rigidbody中的conrstrains中的X轴和Z轴冻结旋转即可防止物体翻车。（这里的旋转都是绕哪个轴旋转）
27. 将Rigidbody中的constrains中冻结位置是不想让物体沿哪个轴运动，如果不想让物体浮空或者掉出平面，就冻结Y轴
28. 如果不知道是哪个类型的，就使用GameObject，因为Unity中的都是GameObject。  eg：public GameObject FireTransform
29. 想要编辑附属的预制体的时候，可以拖出来先修改然后再覆盖 ->应用所有。
30. Rigidbody组件是一个物理组件
31. 变量 += 值 ；等价于先计算左侧变量与右侧变量的和，再赋值给左侧变量； x+=5;相当于x=x+5;
32. 如果修改C#脚本中的数值时，Unity中的变量未更新，点击脚本右侧三个点-> 重置  即可
33. 写方法的时候要随机应变，要根据当前选择的传入变量类型进行变通设计
34. ///是给方法添加描述
35. 按住alt，左键点是一键全部展开，全部折叠
36. 按住shift，全部选中
37. 选中右上角Y，是俯视，此时可以通过鼠标中键拖动画面
38. 相机的投影大小（size）是中心点到上方的距离，也就是半个纵向。若大小为8，分辨率是1.77，半个横向就是8* 1.77
39. F12是跳转到代码的定义Shift+F12是查看当前元素的所有引用位置
 40. 直接定义Vector3和transform.forward的区别
        1. 直接定义Vector3是绝对位置，用于处理相机，背景滚动，平台，需要施加全局力等情况
        2. 使用transform.forward是需要移动方向跟物体朝向一致时使用，一般用于处理需要控制的物体
41. 通过游戏视窗右上角的  -> “在场景中切换所有小工具（小玩意儿  Gizmo）的可见性”  ->  "3D图标" 中调整大小可以使得场景中小的图标变大直到可见
42. 分辨率是屏幕在横向和纵向上显示的像素点数量，与宽高比不用。但是分辨率的比值化简就是宽高比
###### UI设计
1. eventSystem 控制UI操作的
2. Canvas用来承载UI控件，所有的UI控件必须具备Canvas，可以再已有Canvas内继续创建UI，比如滑动条。
3. 第一个控件一定要有Canvas
4. 按F是聚焦；选中Canvas，设置为2D，就进入平面，可以用鼠标进行拖动和拉近。此时比较容易对画布内容进行编辑，通过往其中添加UI控件。
5. 对UI中的值直接赋值或者映射关系来实现Slider的变化，比如血量，可以通过映射关系，也可以直接赋值
6. Canvas渲染模式改成世界空间，就相当于是世界的物体了，设置成指定物体的子物体，里面的slider就可以一起移动了
7. 将Canvas内的组件全选，点击stretch，最右边最下面是拉伸，是对中间区域的操作；按住alt拉伸，是直接拉伸到最右边最左边；这里是对齐方式和拉伸的布局九宫格；选中，点击进行操作。
8. Slider-> Fill -> 图像类型   ，eg：图像类型-> 已填充  ；可以更改Fill Area的填充方式。通过更改 Slider中的方向，也能更改填充的方式；也可以更改填充原点，顺逆时针。
9. 通过颜色中的Alpha通道来更改透明度
10. 创建文本对象
     1. 操作：UI ->  画布 ,先创建一个画布。
     2. 操作：右键创建好的画布，UI  ->   旧版  ->   文本
     3. 字体中的最佳适应勾选，是选择文本在不同大小的屏幕上的字体大小范围
     4. 如果字体想要阴影效果，添加Shadow( 阴影)组件
     5. 更改文本在屏幕上显示的大小（这里不是字体了），需要更改锚点。
        1. eg：锚点最小XY均为0.1，最大XY为0.9；将custom的数据（左右顶底位置Z）全部改成0。就可以将文本改成大的。
        2. 这里的锚点就是文本框的长和宽，就是到Canvas边框的占比；
        3. custom是在已经定好的锚点下，更改文本框的位置
            1. 就是更改文本框距离已经定好锚点的位置
            2. 全部设置为0就是充满整个文本框，就是不对文本框在已经定好的锚点下进行更改。
###### 一些方法
1. 移动的时候斜着走速度更快，因为是向量的加法，合速度更快。这种问题可以解决，在向量后方 **.normalized** 。这是归一化，返回一个大小为1的向量同时方向不变，同于获取单位向量表示。
2. Mathf.Abs()   //用来取float类型或者int类型参数的绝对值。这两种类型都会返回参数的绝对值
3. Random.Range// 返回一个介于最小值和最大值之间的随机浮点数，且这两个边界值都有可能被返回
4. Input.GetAxis()//是用来获取轴线的值，是获取连续值的。比如水平或者垂直的移动
5. GameObject gameObjectInstance= Instantiate(GameObject orignal,Vector3 positon,Quarternion rotation)，
    1. 此处的Quarternion rotation，由于transform.rotation=Quaternion.Euler(x,y,z)，这里需要四元数形式的rotation，
    2. 在Unity中，Euler Angle是Vector3类型的，而Transform.rotation是存储的四元数信息。所以这里直接使用GameObject的.transform.rotation即可
    3. 用于实例化物体，比如说实例化炮弹或者是爆炸的粒子系统
    4. 重载之一： Instantiate(Object orignal, Vector3 positon, Quarternion rotation,Transform parent ) 
         实例化（要复制的现有对象，新对象的位置，新对象的方向，要指定给新对象的父对象）
    
7. 重载是方法名字一样，传递参数不一样
8. OnTriggerEnter(Collider other)  
     1. 在进入触发时（碰撞器 other）意思就是当前物体触发了另一个物体的碰撞器。
     2. other是另一个物体的碰撞器组件
     3. 要勾选当前物体的Box Collider中的**触发器**才行
9. GameObject.SetActive(bool value)  //激活/停用 GameObject。    eg：other.gameObject.SetActive(false)
10. OnEnable // 常用于执行​与启用状态相关的初始化操作​，尤其是那些​需要重复执行​*（禁用后再次启用时）或​必须在Start()之前完成​的操作。
    1. 当脚本附加的游戏对象被启用的时候，Unity会自动调用OnEnable方法，在Awake后，Start前。
    2. 当脚本或者游戏对象被禁用了，SetActive(false)或者取消了脚本的勾选时，再次被启用的时候会调用OnEnable，而Start和Awake就不调用了
    3. 可以通过先设置.SetActive(false);再设置.SetActive(true);来调用OnEnable方法，可以使得物体进行初始化，或者重置物体。
        1. 类比for循环利用赋予bool值来启动，由于for循环也是对bool值的判断。
        2. eg：bool bo1=true;    for(  ; bo1;) {  循环体内容}这样直接可以构造和控制for循环。
        3. 通过try和catch内对bo1的布尔值的改变，实现控制for循环
    
11. Physics.OverlapSphere(Vector3 position, float radius, int layerMask)
     1. 获取一个半径为radius，中心在position的球内或者跟球接触的所有指定的物体的碰撞器
     2. 返回一个碰撞器数组 Collider[ ]   
     3.  layer 也就是层，layerMask  是层掩码 。
     4. layer 层是用来给物体贴上标签的，比如：房子，人，车。。
     5. layerMask 层掩码 ：是一个选择或者过滤器，是用来选择标签的，层掩码是图层索引的2的幂次方。
12. continue；//是直接跳过当前循环
13. Rigidbody.AddExplosionForce (float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier= 0.0f,mode= ForceMode.Force));
     1. 写默认值的是可选参数，));的意思是有可选参数
     2. 这个Rigidbody里的方法是想模拟爆炸效果的刚体施加力
     3. （爆炸的力，爆炸中心，爆炸半径，向上修正量//人为添加一个向上的力的分量，实现掀翻效果，力的作用模式//这里是默认的，意思是持续M力）
     4. ForceMode.Force 施加持续力       ForceMode.Impulse    施加瞬间冲量（物体获得瞬间的速度，受质量影响）
     5. ForceMode.Acceleration 施加加速度   （以一个相同加速度运动，不受质量影响）    ForceMode.VelocityChange  施加速度变化 （物体瞬间改变速度，不受质量影响）
     6. 使用命名参数语法也不能不写upwardsModifier参数：mode:  ForceMode.Impulse  ，或者直接写上upwardsModifier的默认值0.0f,也可以
   
14. Vector3  v3    ;v3.magnitude // 返回该向量得长度，是计算了平方根的。
15. Mathf.Max(float a, float b)  // 返回两个数中的最大值，如果用来伤害返回可以通过Mathf.Max（0，damage）来使得伤害返回不为负值
16. ParticleSystem// 是粒子特效组件
17. Mathf.Clamp(float value,float min,float max)  //  将给定的值限制(钳制）在指定的最小浮点数和最大浮点数之间。如果值在最小值和最大值范围内，则返回该值。
18. Color.lerp(Color a,Color b,float t)   
     1. lerp：插值
     2. = a+(b-a)* t
     3. t为0为颜色a，t为1为颜色b
     4. 从a开始到b结束
     5. t是a和b的一个占比。t越接近1，b占比越大，输出的是一个a和b中间的一个颜色
     6. 可以用当前血量/满血血量 =t  来实现血条颜色随着当前血量的变化而变化
19. GetComponentInChildren < Camera>(  ) ；   //从子物体中获取相机组件，只有一个相机组件的时候可以这样写
20. .gameObject.activeSelf    //表示物体的Active状态
21. transform.position=Vector3.SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity,  float smoothTime, float maxSpeed=Mathf.Infinity, float deltaTime=Time.deltaTime )
	1. （当前位置，目标位置，当前速度（由函数在每次调用时进行修改），达到目标位置所需近似时间（过渡时间），可以选择允许限制最大速度，上次调用此函数以来的时间）
	2. 随时间推移将一个向量之间改编为所需目标，用于移动位置。
	3. 向量通过类似于弹簧阻尼的函数进行平滑，一般用于平滑跟随相机。
	4. eg：transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, smoothTime);后面的maxSpeed和dletaTime都可以用默认值
	5. ref  //意思是允许在方法中修改变量的值，并将这些更改反应回调用方法。该关键字用于参数的传递。这里是用于传参，将当前的速度传给物体。后续也可以修改
22. Vector3 V3=A.transform.inversetransformPoint (v3)
    1. 逆变换点
    2. 相当于是将坐标从世界空间转变为本地空间
    3. 意思就是将物体v3的坐标从世界左边转换为以物体A为中心的坐标，将A视为坐标的原点
    4. 是计算物体v3相对于物体A的位置
    5. 该方法用于捕获相机的视野，如果不将世界坐标转换为以相机为中心的坐标，如果相机有旋转，会因为相机的坐标轴和世界坐标轴不一致而导致计算的结果错误从而捕获不到物体。
23. Camera.aspect  宽高比，根据屏幕宽高比自动计算该宽高比。
24. MonoBehaviour，是Unity项目的C#脚本自动继承的类，允许将脚本附加到游戏对象，提供常用的事件；包含多个生命周期方法。
25. Mathf.SmoothDamp(float current, float target, ref float currentVelocity,  float smoothTime, float maxSpeed=Mathf.Infinity, float deltaTime=Time.deltaTime )
     1. 类比Vector3.SmoothDamp()
     2. 随时间推移将一个值平滑过渡到目标值
 26. .enabled是用于启用或者禁用特定组件的属性。eg：Movement.enabled=false；//禁用移动组件
 27. [ Serializable ] （可序列化） 是一个用于标记类可以被序列化的特性
     1. 序列化是将对象的状态转换为可存储或者传输的形式的过程
	     1. 允许在Inspector中编辑，在预制体中保存，在场景中持久化
     2. [ Serializable ]仅仅是一个标记，是告诉序列化器该类可以被序列化
     3. **使用场景**
	     1. 创建自定义的数据结构（比如物品类，配置类）
	     2. 需要在Inspector中显示的复杂类型
	     3. 需要保存和加载的自定义对象
28. [SerializeField] （序列化字段）是强制序列化私有的字段或者手保护的字段，让其在Inspector中可见和编辑
	1. eg：[SerializedFiled] private float health =100f;//将私有的字段在Inspector中可见
	2. **使用场景** 
		1. 封装数据（保持字段私有），但是数据需要在Inspector中调试
		2. 控制哪些字段应该在Inspector中显示
######  按键检测
1.  Input.GetButtonDown() 是用来检测按钮是否按下的，是离散事件，只在按钮按下的那一刻返回true，之后就不再触发了，直到再次按下按钮。比如用于处理跳跃，射击等动作。
2. Input.GetButtonDown(string buttonName)  （在某帧）当与buttonName一致的虚拟按钮被按下时，返回true。在实现武器开火等时候使用，此处的buttonName是在获取轴线信息时Input.GetAxis( string axisName )；中的 axisName 。也就是Input Manager中的Axis（轴线信息）中的按钮列表的名称。
3. Input.GetButton 用于检测按钮是否已经按下了（按住），用于检测按钮是否被持续按住,松开就返回false了
4. Input.GetButtonUp用于检测按钮是否回弹，在按钮回弹时返回true
###### 父子级    
1. 父子级时，父级改变（ ）。子级也会做出一起的改变，就相当于成了一个整体
2. 建立一个空对象，将组件全放入，都成为这个空对象的子级时，改变这个空对象（父级）就相当于是整体改变，对里面的子级也可以进行分别单独修改。比如：在桥上创建石狮子。就相当于在父级（桥）上面添加子级。
3.  相机和空对象组成父子级物体（相机装置）后
      1. 是以中心为坐标轴的，要将轴心改成轴心，就变成模型原始位置了。
      2. 轴心点是模型原始位置，中心点是模型网络的几何中心。
      3. 把main Canmera给一个点（创建的空对象），就可以方便相机得移动了，相当于打标记。
      4. 需要将他们的旋转XYZ统一，这样父物体沿着哪个轴移动，子物体也会沿着与父物体相同的轴方向移动，不会出现父物体沿着X轴移动，子物体不是沿着自己的X轴移动的情况。
      5. 如果空对象内只有一个相机组件，就可以将相机设置为private然后再awake内获取组件即可；如果有多个相机组件，则需要对组件public然后将对应的相机拖给它
       

###### 空对象，预制体
1. Game Object（空对象），可以通过添加对应的组件，比如 mesh filter ，mesh renderer。空对象添加colloder（碰撞器）组件，可以形成空气墙。
2. prefab(预制体)，把组合好的物体打包成一个预制体，就能复用在各个地方了，直接把组合好的物体拖到下面的Assets（资源，资产）内。双击Assets内的预制体，可以直接对预制体进行修改，点击返回后，可以完成对所有预制体进行同时的修改。
3. 预制体就是创建一个空对象，然后把想组合的物体全部放进去
4. 对已经配置好的物体，可以直接打包成预制体，方便在不同的场景中进行使用

###### GameManager
1. 将物体相关的属性全部打包成一个类型
    1. 相当于是建立了一个物体和类型的映射关系
    2. 通过实例化（初始化）类型来直接对该类型内的属性进行修改；
    3. 对这个类型进行操作就相当于是对场景中的物体进行操作。
    4. eg：直接暴露tankManager中的参数，将对应的组件拖过去，然后使用的时候就可以直接进行调用
2. 协程（coroutine）
    1. 协程是主线程的一部分，它会占用主线程的执行时间，只有通过yield主动让出控制权，其他代码才有机会执行
    2. 协程是和生命周期函数或者其他的方法交替进行的
	3. 如果GameLoop()协程内存在yield return，会暂停，如果设置了时间，则会暂停相应的时间后，再次执行。
         1. Yield Return Null
            1. 用于暂停协程的执行，并在下一帧继续执行执行。
            2. 如果再while循环内，每一帧都会执行一次循环体（yield return null），然后协程暂停，下一帧再回来检查条件。就是跳出这个，执行后续的代码。
         2. yield return new WaitForSeconds(float seconds);      等待给定的时间后，继续执行
         3. yield return new WaitForEndOfFrame()；    等待当前帧结束后，继续执行
         4. yield return new WaitForFixedUpdate();       等待下一个物体更新帧执行
         5. 协程方法需要使用 IEnumerator接口  //接口名称以大写I开头； 也就是枚举器接口。eg：private IEnumerator GameLoop()  {    //方法内容  }
         6. 如果协程内有其他协程，eg：yield return StartCoroutine(RoundStarting());   
             1. 启动RoundStaring()协程，并且暂停当前的GameLoop()协程
             2. 等待RoundStaring()协程全部执行完后，再恢复执行GameLoop()协程
        7. 如果用协程嵌套的形式来表示，并且内层协程中的yield return代码在内部协程的内容最后一行，则会等待给定的时间或者执行暂停等操作之后跳出本内层协程。
3. 背景音乐设置：在GameManager内添加AudioSource组件，添加音频文件；选择：在唤醒时播放，循环
### 一些其他操作知识
#### tank 场景环境设置
1. 依次点击：窗口 -> 渲染 -> 照明
2. 切换到环境Tab页面
3. 环境照明 -> 源  改为 颜色
4. 环境颜色 改为  （72，62，113）
5. 点击GenerateLight
#### tank设置
##### 设置碰撞器的位置和大小
1. 位置（0，0.85，0）
2. 大小（1.5，1.7，1.6）
##### 设置相机
1. 修改相机位置（-42，42，-25）
2. 修改相机旋转（40，60，0）
3. 修改相机   投影  -> 投影  正交   
	1. 透视投影遵从近大远小
		1. z轴的坐标被非线性压缩，产生近大远小的效果
		2. z轴的缩放和x，y轴的不同
		3. 最后也要缩放到标准立方体中（[ -1,1]^3的立方体)
	2. 正交投影是物体大小不随距离变化而变化。
		1. 将物体的中心点移动到原点后，进行缩放；缩放到标准立方体中（[ -1,1]^3的立方体)
		2. 正交投影是一种平行投影，类似用一束平行光把物体的影像垂直地投射到地面上。
4. 设置  环境 ->  背景类型  纯色
5. 设置  环境 ->  背景  （80，60，50）

##### 轴线相关信息
1. 编辑-> 项目管理器 -> 输入管理器-> 轴线
2. 轴线代表的是28个按键信息，在输入管理器中设置好之后，在代码中调用Input.GetAxis()的时候，就会获取键盘的按键，通过键盘的按键来反馈对应的响应。这是Unity自带的键盘映射。
3. 导入的资源模板的信息，会将所有的东西，包括按键信息也导入进来。
4. 当设置同一个名字，但是两种类型不同的轴线时，可以通过不同类型的操作获取相同的信息。比如：都是Horizontal，类型1是操作杆轴，类型2是按键或鼠标按钮，通过这两种按键都可以获取到对应的轴的信息。
##### 声音相关的设置
1. 选择音频文件AudioClip，点循环的话就可以一直播放，不然音频文件是有时间的，时间到了就会结束，比如tank发动机怠速的声音，要一直运行。
2. 运动的时候要播放另一种声音
##### 尾气设置（粒子特效）
1. 左边粒子特效（-0.5，0，0.75）
2. 右边粒子特效（0.5，0，0.75）
##### 炮弹设置
1. 是按住某个按键之后，炮弹被代码动态的创建出来.
2. 位置（0，1.7，1.35）
3. 旋转（350，0，0）
4. 可以添加Light组件
##### 炮弹发射思路
按下开始充能开始，按住进行充能，松开击发炮弹。需要使用if，else if ，else if来检测每帧的按钮是否为3种状态中的一种
1. 检测按钮是否被按下
2. 最小充能力或者在最小和最大力之间的时候，按钮回弹时触发（而不是按下就击发）
3. 一直按住开火按钮不动，刚到最大的充能力或者已经达到最大充能力时还未松开，回弹时按照最大充能力发射
通过if ，else if，else if，结构来判断按钮的每帧状态，每帧都会检测一次按钮是否满足三种情况的哪一种，这种结构是触发一种就直接跳出。
##### 炮弹蓄力时的处理思路
1. 蓄满力的时候不发射，回到最小值重新蓄力
2. 蓄满力不发射，维持蓄满状态
3. 蓄满力先发射，再回到最小值重新蓄力。然后继续按住，又继续蓄力，蓄满之后又可以发射  。可以实现按住自动充能连射
4. 蓄满力时维持蓄满状态，发射。  可以实现蓄满后以最大力进行连发
5. 蓄满力时，以同样的速度减少力，最终回到最小。   可以实现按住来回不断充能读条
6. 按下按钮，自动蓄力，蓄满不发射，以同样速度减小力，最终回到最小再次。
    1. 通过判断是否在蓄力来启动蓄力；第一次按下按钮，不在蓄力则启动蓄力；第二次按下按钮在蓄力则发射。
    2. 进入蓄力过程中时，通过是否在增加（通过对一个变量的布尔值）来判断对力增加还是减少，增加到最大时，布尔值为false，下一帧进入减小蓄力
    3. 通过当前帧对布尔变量的赋值改变，来进入或者离开蓄力状态
##### 画布大小调整
1. 位置XYZ     ( 0,0.1,0)
2. 宽度高度（3.5，3.5）
3. 旋转XYZ  (90,0,0)
4. 每单位参考像素-> 1
##### 游戏初始化tank生成
1. 创建空对象定位

##### 音频混合器
###### 音量压制 
1. 在Assets内创建文件夹，比如：AudioMixers；
2. 在文件夹内添加音频混合器
3. 音频混合器可在：窗口-> 音频->音频混合器中显示   //可以拖到场景并列处，方便调试
4. 音频混合器中，在**组**内添加新的**子组**，比如Music，SFX（音效），Driving 等声音；
5. 将游戏内的音频全部指向音频混合器；将AudioSource的**输出**选择为创建的**音频混合器的相对应的组**，
	1. eg：在GameManager内添加AudioSource ；音频文件选择BGM. 
	2. 将GameManager内的AudioSource的**输出**选择为创建的MainMix(创建的音频混合器的名称)内的Music
6. 可以在音频混合器内进行游戏内音频的音量大小调整
###### 一些理解
1. SFX触发的时候，让Music静音或者降低
	1. 在Music内添加 Duck Volume 
		1. Duck Volume  音频闪避（降低）
			1. 用于自动降低某个音频源的音量，来响应另一个音频源的播放。eg：爆炸，说话等等的时候降低背景音
			2. 是一个自动音量控制系统，检测一个主导音频源的信号，来临时降低被闪避音频源的音量
			3. 通过send（触发信号）发送到Duck Volume （这个压缩器）来进行工作；类比于一个触发器，接收触发信号，然后应用音频的变化
		2. **Duck Volume 内容详解**
			1. 阈值 Threshold：触发Duck Volume的效果音量达到的大小
			2. 比率 Ratio : 音量压缩的强度比例。//将超过阈值的信号进行压缩，信号每增加2.5分贝，输出只增加1分贝
			3. 起音时间 Attack Time:  效果启动的响应速度（时间）
			4. 释音时间 Release Time: 效果结束的回复时间
			5. 补偿增益 Make-up Gain : 整体输出电平补偿。//将处理后的整体音量进行调整
			6. 拐点  Knee : 阈值过渡区域的平滑度。//拐点宽度是在阈值附近提供过渡区域，防止突兀的音量变化
			7. 侧链混合 Side Mix : 外部控制信号的影响程度。//表示由外部音频控制闪避效果的程度。eg：100%为完全由侧链信号控制闪避效果，不使用音频自身作为触发条件
	2. 在SFX内添加send（发射源）
		1. 这里的作用为控制信号，而非混合信号
		2. 控制信号的发送级别不应过高或者过低，不然会导致背景音的起伏过于明显，失去自然的变化。一般为0db
##### 游戏打包
1. 在文件生成设置（build Settings，也是翻译问题，应该为构建）内，先将场景进行选择和设置
2. 选择平台和平台具体的属性
3. 在**玩家设置**（英文是Project Settings，翻译问题）内进行：玩家，广告，分辨率等等内容的设置
	1. 游戏运行的设置都在**玩家设置**内
	2. 相当于是打包出来什么东西的设置
###### BuildTargetGroup
1. 构建目标组
2. 由于需要将游戏打包到不同的平台，eg：Android, iOS,Windows,Mac,...
3. **BuildTargetGroup**是一个平台的大类标签，将需要打包的平台进行分组
	1. 有些设置是一组平台（Windows,Mac,Linux,...)共用的
	2. 可以一次性对一组平台使用相同的设置
	3. 可以在代码里用条件编译区分不同的平台组